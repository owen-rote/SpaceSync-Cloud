#!/bin/bash

# Function to create a POST request with a curl command
create_curl_request() {
  curl -X 'POST' \
    'http://localhost:8000/tasks/' \
    -H 'accept: application/json' \
    -H 'Content-Type: application/json' \
    -d "{ \"code\": \"$1\" }"
}

# Task 1
create_curl_request "function fib() { let a = 0, b = 1, temp; for (let i = 0; i < 1000000; i++) { temp = a; a = b; b = temp + b; } return a; } fib();"

# Task 2
create_curl_request "function factorial() { let result = 1n; for (let i = 1n; i <= 5000n; i++) { result *= i; } return result.toString(); } factorial();"

# Task 3
create_curl_request "function primeCount() { let count = 0; for (let i = 2; i < 100000; i++) { let isPrime = true; for (let j = 2; j * j <= i; j++) { if (i % j === 0) { isPrime = false; break; } } if (isPrime) count++; } return count; } primeCount();"

# Task 4
create_curl_request "function mandelbrot() { let width = 100, height = 100, maxIter = 1000, count = 0; for (let x = 0; x < width; x++) { for (let y = 0; y < height; y++) { let zx = 0, zy = 0, cx = x / width * 3.5 - 2.5, cy = y / height * 2.0 - 1.0, iter = 0; while (zx * zx + zy * zy < 4 && iter < maxIter) { let tmp = zx * zx - zy * zy + cx; zy = 2.0 * zx * zy + cy; zx = tmp; iter++; } count += iter; } } return count; } mandelbrot();"

# Task 5
create_curl_request "function monteCarloPI() { let inside = 0, total = 1000000; for (let i = 0; i < total; i++) { const x = Math.random(), y = Math.random(); if (x * x + y * y <= 1) inside++; } return (4 * inside / total).toFixed(6); } monteCarloPI();"

# Task 6
create_curl_request "function matrixMult() { const size = 100, A = [], B = [], C = []; for (let i = 0; i < size; i++) { A[i] = []; B[i] = []; C[i] = []; for (let j = 0; j < size; j++) { A[i][j] = Math.random(); B[i][j] = Math.random(); C[i][j] = 0; } } for (let i = 0; i < size; i++) { for (let j = 0; j < size; j++) { for (let k = 0; k < size; k++) { C[i][j] += A[i][k] * B[k][j]; } } } return C[0][0]; } matrixMult();"

# Task 7
create_curl_request "function sortLargeArray() { const arr = []; for (let i = 0; i < 1000000; i++) arr.push(Math.random()); arr.sort(); return arr[0]; } sortLargeArray();"

# Task 8
create_curl_request "function sha256Simulation() { let str = ''; for (let i = 0; i < 100000; i++) str += String.fromCharCode(65 + (i % 26)); let hash = 0; for (let i = 0; i < str.length; i++) { hash = (hash << 5) - hash + str.charCodeAt(i); hash |= 0; } return hash; } sha256Simulation();"

# Task 9
create_curl_request "function piDigits() { let q=1n, r=0n, t=1n, k=1n, n=3n, l=3n, digits=''; for (let i = 0; i < 1000; i++) { if (4n*q+r-t < n*t) { digits += n; r = 10n*(r - n*t); n = ((10n*(3n*q+r))/t) - 10n*n; q *= 10n; } else { r = (2n*q+r)*l; n = (q*(7n*k+2n)+r*l)/(t*l); q *= k; t *= l; l += 2n; k += 1n; } } return digits.slice(0, 10); } piDigits();"

# Task 10
create_curl_request "function largeExponent() { return Math.pow(1.000001, 1000000); } largeExponent();"

# Task 11
create_curl_request "function imageProcessingSimulation() { const width = 1000, height = 1000; let sum = 0; for (let i = 0; i < width; i++) { for (let j = 0; j < height; j++) { sum += Math.sin(i) * Math.cos(j); } } return sum; } imageProcessingSimulation();"

# Task 12
create_curl_request "function collatzConjecture() { let longest = 0, number = 0; for (let i = 2; i < 1000000; i++) { let n = i, steps = 0; while (n !== 1) { n = n % 2 === 0 ? n / 2 : 3 * n + 1; steps++; } if (steps > longest) { longest = steps; number = i; } } return number; } collatzConjecture();"

# Task 13
create_curl_request "function fourierTransformSimulation() { const size = 1024; const real = [], imag = []; for (let i = 0; i < size; i++) { real[i] = Math.sin(i * 0.1); imag[i] = 0; } let result = 0; for (let k = 0; k < size; k++) { let re = 0, im = 0; for (let n = 0; n < size; n++) { const angle = -2 * Math.PI * k * n / size; re += real[n] * Math.cos(angle) - imag[n] * Math.sin(angle); im += real[n] * Math.sin(angle) + imag[n] * Math.cos(angle); } result += Math.sqrt(re * re + im * im); } return result / size; } fourierTransformSimulation();"

# Task 14
create_curl_request "function neuralNetworkForward() { const inputSize = 784, hiddenSize = 128, outputSize = 10; const input = Array(inputSize).fill(0).map(() => Math.random()); const w1 = Array(hiddenSize).fill(0).map(() => Array(inputSize).fill(0).map(() => Math.random() * 0.01)); const b1 = Array(hiddenSize).fill(0).map(() => Math.random() * 0.01); const w2 = Array(outputSize).fill(0).map(() => Array(hiddenSize).fill(0).map(() => Math.random() * 0.01)); const b2 = Array(outputSize).fill(0).map(() => Math.random() * 0.01); const hidden = Array(hiddenSize).fill(0); for (let i = 0; i < hiddenSize; i++) { for (let j = 0; j < inputSize; j++) { hidden[i] += input[j] * w1[i][j]; } hidden[i] = Math.tanh(hidden[i] + b1[i]); } const output = Array(outputSize).fill(0); for (let i = 0; i < outputSize; i++) { for (let j = 0; j < hiddenSize; j++) { output[i] += hidden[j] * w2[i][j]; } output[i] = 1 / (1 + Math.exp(-(output[i] + b2[i]))); } let maxIndex = 0; for (let i = 1; i < outputSize; i++) { if (output[i] > output[maxIndex]) maxIndex = i; } return maxIndex; } neuralNetworkForward();"

# Task 15
create_curl_request "function mergeSort() { function sort(arr) { if (arr.length <= 1) return arr; const mid = Math.floor(arr.length / 2); const left = sort(arr.slice(0, mid)); const right = sort(arr.slice(mid)); return merge(left, right); } function merge(left, right) { const result = []; let i = 0, j = 0; while (i < left.length && j < right.length) { if (left[i] < right[j]) { result.push(left[i]); i++; } else { result.push(right[j]); j++; } } return result.concat(left.slice(i)).concat(right.slice(j)); } const arr = Array(100000).fill(0).map(() => Math.random()); return sort(arr)[0]; } mergeSort();"

# Task 16
create_curl_request "function raytracing() { const width = 100, height = 100; let color = 0; for (let y = 0; y < height; y++) { for (let x = 0; x < width; x++) { const rayX = (x / width) * 2 - 1; const rayY = (y / height) * 2 - 1; const rayZ = -1; const length = Math.sqrt(rayX * rayX + rayY * rayY + rayZ * rayZ); const normalizedX = rayX / length; const normalizedY = rayY / length; const normalizedZ = rayZ / length; const sphereX = 0, sphereY = 0, sphereZ = -5, sphereRadius = 1; const a = normalizedX * normalizedX + normalizedY * normalizedY + normalizedZ * normalizedZ; const b = 2 * (normalizedX * (0 - sphereX) + normalizedY * (0 - sphereY) + normalizedZ * (0 - sphereZ)); const c = (0 - sphereX) * (0 - sphereX) + (0 - sphereY) * (0 - sphereY) + (0 - sphereZ) * (0 - sphereZ) - sphereRadius * sphereRadius; const discriminant = b * b - 4 * a * c; if (discriminant >= 0) color++; } } return color; } raytracing();"

# Task 17
create_curl_request "function geneticAlgorithmSimulation() { const populationSize = 1000, generations = 100; let population = Array(populationSize).fill(0).map(() => Array(10).fill(0).map(() => Math.random())); for (let g = 0; g < generations; g++) { const fitness = population.map(individual => individual.reduce((sum, gene) => sum + gene, 0)); const maxFitnessIndex = fitness.indexOf(Math.max(...fitness)); const fittest = population[maxFitnessIndex]; const newPopulation = [fittest]; while (newPopulation.length < populationSize) { const i = Math.floor(Math.random() * populationSize); const j = Math.floor(Math.random() * populationSize); const parent1 = population[i], parent2 = population[j]; const crossoverPoint = Math.floor(Math.random() * 10); const child = []; for (let k = 0; k < 10; k++) { child[k] = k < crossoverPoint ? parent1[k] : parent2[k]; if (Math.random() < 0.1) child[k] = Math.random(); } newPopulation.push(child); } population = newPopulation; } const finalFitness = population.map(individual => individual.reduce((sum, gene) => sum + gene, 0)); return Math.max(...finalFitness); } geneticAlgorithmSimulation();"

# Task 18
create_curl_request "function speechRecognitionSimulation() { const frameSize = 256, frameCount = 1000; let mfccs = Array(frameCount).fill(0).map(() => Array(13).fill(0)); for (let i = 0; i < frameCount; i++) { const frame = Array(frameSize).fill(0).map(() => Math.random() * 2 - 1); let sum = 0; for (let j = 0; j < 13; j++) { for (let k = 0; k < frameSize; k++) { mfccs[i][j] += frame[k] * Math.cos(Math.PI * j * (k + 0.5) / frameSize); } sum += mfccs[i][j] * mfccs[i][j]; } sum = Math.sqrt(sum); for (let j = 0; j < 13; j++) mfccs[i][j] /= sum; } let distance = 0; const template = Array(13).fill(0).map(() => Math.random() * 2 - 1); for (let i = 0; i < frameCount; i++) { let frameDist = 0; for (let j = 0; j < 13; j++) { frameDist += (mfccs[i][j] - template[j]) * (mfccs[i][j] - template[j]); } distance += Math.sqrt(frameDist); } return distance / frameCount; } speechRecognitionSimulation();"

# Task 19
create_curl_request "function kMeansClustering() { const pointCount = 10000, dimensionCount = 10, clusterCount = 10; const points = Array(pointCount).fill(0).map(() => Array(dimensionCount).fill(0).map(() => Math.random())); let centroids = Array(clusterCount).fill(0).map(() => Array(dimensionCount).fill(0).map(() => Math.random())); for (let iter = 0; iter < 20; iter++) { const clusters = Array(clusterCount).fill(0).map(() => []); for (let i = 0; i < pointCount; i++) { let minDist = Infinity, minCluster = 0; for (let j = 0; j < clusterCount; j++) { let dist = 0; for (let k = 0; k < dimensionCount; k++) { dist += (points[i][k] - centroids[j][k]) * (points[i][k] - centroids[j][k]); } if (dist < minDist) { minDist = dist; minCluster = j; } } clusters[minCluster].push(i); } for (let j = 0; j < clusterCount; j++) { if (clusters[j].length === 0) continue; for (let k = 0; k < dimensionCount; k++) { let sum = 0; for (let i = 0; i < clusters[j].length; i++) { sum += points[clusters[j][i]][k]; } centroids[j][k] = sum / clusters[j].length; } } } let totalDistance = 0; for (let i = 0; i < pointCount; i++) { let minDist = Infinity; for (let j = 0; j < clusterCount; j++) { let dist = 0; for (let k = 0; k < dimensionCount; k++) { dist += (points[i][k] - centroids[j][k]) * (points[i][k] - centroids[j][k]); } minDist = Math.min(minDist, dist); } totalDistance += minDist; } return totalDistance / pointCount; } kMeansClustering();"

# Task 20
create_curl_request "function compression() { const length = 100000; const data = Array(length).fill(0).map(() => Math.floor(Math.random() * 256)); const dict = new Map(); let result = [], w = ''; for (let i = 0; i < length; i++) { const c = data[i]; const wc = w + ',' + c; if (dict.has(wc)) { w = wc; } else { result.push(w ? dict.get(w) : c); dict.set(wc, dict.size + 256); w = String(c); } } if (w !== '') result.push(w ? dict.get(w) : parseInt(w)); return result.length / length; } compression();"

# Task 21
create_curl_request "function quicksort() { function sort(arr, left, right) { if (left < right) { const pivotIndex = partition(arr, left, right); sort(arr, left, pivotIndex - 1); sort(arr, pivotIndex + 1, right); } } function partition(arr, left, right) { const pivot = arr[right]; let i = left - 1; for (let j = left; j < right; j++) { if (arr[j] <= pivot) { i++; [arr[i], arr[j]] = [arr[j], arr[i]]; } } [arr[i + 1], arr[right]] = [arr[right], arr[i + 1]]; return i + 1; } const arr = Array(100000).fill(0).map(() => Math.random()); sort(arr, 0, arr.length - 1); return arr[0]; } quicksort();"

# Task 22
create_curl_request "function graphTraversal() { const vertices = 5000, edges = 50000; const graph = Array(vertices).fill(0).map(() => []); for (let i = 0; i < edges; i++) { const u = Math.floor(Math.random() * vertices); const v = Math.floor(Math.random() * vertices); graph[u].push(v); } const visited = Array(vertices).fill(false); function dfs(node) { visited[node] = true; let count = 1; for (const neighbor of graph[node]) { if (!visited[neighbor]) { count += dfs(neighbor); } } return count; } return dfs(0); } graphTraversal();"

# Task 23
create_curl_request "function convolution() { const inputSize = 128, kernelSize = 7, padding = 3; const input = Array(inputSize).fill(0).map(() => Array(inputSize).fill(0).map(() => Math.random())); const kernel = Array(kernelSize).fill(0).map(() => Array(kernelSize).fill(0).map(() => Math.random())); const outputSize = inputSize + 2 * padding - kernelSize + 1; const output = Array(outputSize).fill(0).map(() => Array(outputSize).fill(0)); for (let i = 0; i < outputSize; i++) { for (let j = 0; j < outputSize; j++) { for (let k = 0; k < kernelSize; k++) { for (let l = 0; l < kernelSize; l++) { const x = i + k - padding, y = j + l - padding; if (x >= 0 && x < inputSize && y >= 0 && y < inputSize) { output[i][j] += input[x][y] * kernel[k][l]; } } } } } let sum = 0; for (let i = 0; i < outputSize; i++) { for (let j = 0; j < outputSize; j++) { sum += output[i][j]; } } return sum; } convolution();"

# Task 24
create_curl_request "function dijkstra() { const vertices = 1000, edges = 10000; const graph = Array(vertices).fill(0).map(() => Array(vertices).fill(Infinity)); for (let i = 0; i < vertices; i++) graph[i][i] = 0; for (let i = 0; i < edges; i++) { const u = Math.floor(Math.random() * vertices); const v = Math.floor(Math.random() * vertices); const w = Math.random() * 100; graph[u][v] = w; } const dist = Array(vertices).fill(Infinity); const visited = Array(vertices).fill(false); dist[0] = 0; for (let i = 0; i < vertices - 1; i++) { let minDist = Infinity, minIndex = -1; for (let j = 0; j < vertices; j++) { if (!visited[j] && dist[j] < minDist) { minDist = dist[j]; minIndex = j; } } if (minIndex === -1) break; visited[minIndex] = true; for (let j = 0; j < vertices; j++) { if (!visited[j] && graph[minIndex][j] !== Infinity && dist[minIndex] + graph[minIndex][j] < dist[j]) { dist[j] = dist[minIndex] + graph[minIndex][j]; } } } return dist[vertices - 1]; } dijkstra();"

# Task 25
create_curl_request "function rbf() { const dataPoints = 1000, dimensions = 10; const data = Array(dataPoints).fill(0).map(() => Array(dimensions).fill(0).map(() => Math.random())); const centers = Array(10).fill(0).map(() => Array(dimensions).fill(0).map(() => Math.random())); const gamma = 0.1; function rbfKernel(x, c) { let dist = 0; for (let i = 0; i < dimensions; i++) { dist += (x[i] - c[i]) * (x[i] - c[i]); } return Math.exp(-gamma * dist); } const output = Array(dataPoints).fill(0); for (let i = 0; i < dataPoints; i++) { for (let j = 0; j < centers.length; j++) { output[i] += rbfKernel(data[i], centers[j]); } } return output.reduce((a, b) => a + b, 0) / dataPoints; } rbf();"

# Task 26
create_curl_request "function randomForest() { const samples = 10000, features = 20, trees = 10; const data = Array(samples).fill(0).map(() => Array(features).fill(0).map(() => Math.random())); const labels = Array(samples).fill(0).map(() => Math.random() > 0.5 ? 1 : 0); const forest = []; for (let t = 0; t < trees; t++) { const indices = Array(samples).fill(0).map((_, i) => i).sort(() => Math.random() - 0.5).slice(0, samples); const selectedFeatures = Array(Math.floor(Math.sqrt(features))).fill(0).map(() => Math.floor(Math.random() * features)); const thresholds = selectedFeatures.map(() => Math.random()); forest.push({ features: selectedFeatures, thresholds }); } const predictions = Array(samples).fill(0); for (let i = 0; i < samples; i++) { for (const tree of forest) { let prediction = 0; for (let j = 0; j < tree.features.length; j++) { if (data[i][tree.features[j]] > tree.thresholds[j]) prediction += 1; } predictions[i] += prediction > tree.features.length / 2 ? 1 : 0; } predictions[i] = predictions[i] > trees / 2 ? 1 : 0; } let accuracy = 0; for (let i = 0; i < samples; i++) { if (predictions[i] === labels[i]) accuracy++; } return accuracy / samples; } randomForest();"

# Task 27
create_curl_request "function svmTraining() { const samples = 1000, dimensions = 10, iterations = 100; const data = Array(samples).fill(0).map(() => Array(dimensions).fill(0).map(() => Math.random() * 2 - 1)); const labels = Array(samples).fill(0).map((_, i) => data[i].reduce((sum, x) => sum + x, 0) > 0 ? 1 : -1); let w = Array(dimensions).fill(0), b = 0; const lambda = 0.01, learningRate = 0.01; for (let iter = 0; iter < iterations; iter++) { const i = Math.floor(Math.random() * samples); let wx = 0; for (let j = 0; j < dimensions; j++) { wx += w[j] * data[i][j]; } const pred = wx + b; if (labels[i] * pred < 1) { for (let j = 0; j < dimensions; j++) { w[j] = (1 - learningRate * lambda) * w[j] + learningRate * labels[i] * data[i][j]; } b += learningRate * labels[i]; } else { for (let j = 0; j < dimensions; j++) { w[j] = (1 - learningRate * lambda) * w[j]; } } } let correct = 0; for (let i = 0; i < samples; i++) { let wx = 0; for (let j = 0; j < dimensions; j++) { wx += w[j] * data[i][j]; } const pred = wx + b; if ((pred > 0 ? 1 : -1) === labels[i]) correct++; } return correct / samples; } svmTraining();"

# Task 28
create_curl_request "function pageRank() { const nodes = 1000, edges = 5000, damping = 0.85, iterations = 50; const graph = Array(nodes).fill(0).map(() => []); for (let i = 0; i < edges; i++) { const from = Math.floor(Math.random() * nodes); const to = Math.floor(Math.random() * nodes); if (from !== to) graph[from].push(to); } const outDegree = graph.map(neighbors => neighbors.length); let rank = Array(nodes).fill(1 / nodes); for (let iter = 0; iter < iterations; iter++) { const newRank = Array(nodes).fill((1 - damping) / nodes); for (let i = 0; i < nodes; i++) { for (const neighbor of graph[i]) { newRank[neighbor] += damping * rank[i] / (outDegree[i] || 1); } } rank = newRank; } return rank.reduce((a, b) => a + b, 0); } pageRank();"

# Task 29
create_curl_request "function bayesianNetwork() { const samples = 10000, nodes = 10; const cpt = Array(nodes).fill(0).map((_, i) => { const parents = Array(i).fill(0).map((_, j) => j); const probTable = {}; const combinations = 1 << parents.length; for (let j = 0; j < combinations; j++) { let key = ''; for (let k = 0; k < parents.length; k++) { key += (j & (1 << k)) ? '1' : '0'; } probTable[key] = Math.random(); } return { parents, probTable }; }); const samples_result = Array(samples).fill(0).map(() => { const values = Array(nodes).fill(0); for (let i = 0; i < nodes; i++) { const { parents, probTable } = cpt[i]; let key = ''; for (const parent of parents) { key += values[parent]; } values[i] = Math.random() < probTable[key] ? 1 : 0; } return values; }); let jointProb = 0; for (const sample of samples_result) { if (sample[nodes - 1] === 1) jointProb++; } return jointProb / samples; } bayesianNetwork();"

# Task 30
create_curl_request "function factorization() { const rows = 1000, cols = 500, factors = 10, iterations = 50; const V = Array(rows).fill(0).map(() => Array(cols).fill(0).map(() => Math.random())); const W = Array(rows).fill(0).map(() => Array(factors).fill(0).map(() => Math.random())); const H = Array(factors).fill(0).map(() => Array(cols).fill(0).map(() => Math.random())); const learningRate = 0.001; for (let iter = 0; iter < iterations; iter++) { for (let i = 0; i < rows; i++) { for (let j = 0; j < cols; j++) { let prediction = 0; for (let k = 0; k < factors; k++) { prediction += W[i][k] * H[k][j]; } const error = V[i][j] - prediction; for (let k = 0; k < factors; k++) { W[i][k] += learningRate * error * H[k][j]; H[k][j] += learningRate * error * W[i][k]; } } } } let error = 0; for (let i = 0; i < rows; i++) { for (let j = 0; j < cols; j++) { let prediction = 0; for (let k = 0; k < factors; k++) { prediction += W[i][k] * H[k][j]; } error += (V[i][j] - prediction) * (V[i][j] - prediction); } } return Math.sqrt(error / (rows * cols)); } factorization();"

# Task 31
create_curl_request "function gaborFilter() { const width = 64, height = 64, sigma = 5, theta = Math.PI / 4, lambda = 10, gamma = 0.5, psi = 0; const kernel = Array(width).fill(0).map(() => Array(height).fill(0)); for (let x = 0; x < width; x++) { for (let y = 0; y < height; y++) { const x0 = x - width / 2; const y0 = y - height / 2; const x1 = x0 * Math.cos(theta) + y0 * Math.sin(theta); const y1 = -x0 * Math.sin(theta) + y0 * Math.cos(theta); const factor = Math.exp(-(x1 * x1 + gamma * gamma * y1 * y1) / (2 * sigma * sigma)); const component = Math.cos(2 * Math.PI * x1 / lambda + psi); kernel[x][y] = factor * component; } } const image = Array(width).fill(0).map(() => Array(height).fill(0).map(() => Math.random())); let result = 0; for (let x = 0; x < width; x++) { for (let y = 0; y < height; y++) { result += image[x][y] * kernel[x][y]; } } return result; } gaborFilter();"

create_curl_request "function decisionTree() { const samples = 5000, features = 20, maxDepth = 10; const data = Array(samples).fill(0).map(() => Array(features).fill(0).map(() => Math.random())); const labels = Array(samples).fill(0).map(() => Math.floor(Math.random() * 2)); function calculateGini(labels) { const counts = {}; for (const label of labels) counts[label] = (counts[label] || 0) + 1; let impurity = 1; for (const label in counts) { const prob = counts[label] / labels.length; impurity -= prob * prob; } return impurity; } function findBestSplit(data, labels, features) { let bestGain = 0, bestFeature = -1, bestThreshold = 0; const baseGini = calculateGini(labels); for (const feature of features) { const values = data.map(row => row[feature]); const thresholds = [...new Set(values)].sort(); for (const threshold of thresholds) { const leftIndices = [], rightIndices = []; for (let i = 0; i < data.length; i++) { if (data[i][feature] < threshold) leftIndices.push(i); else rightIndices.push(i); } if (leftIndices.length === 0 || rightIndices.length === 0) continue; const leftLabels = leftIndices.map(i => labels[i]); const rightLabels = rightIndices.map(i => labels[i]); const leftGini = calculateGini(leftLabels); const rightGini = calculateGini(rightLabels); const gain = baseGini - (leftLabels.length / labels.length * leftGini + rightLabels.length / labels.length * rightGini); if (gain > bestGain) { bestGain = gain; bestFeature = feature; bestThreshold = threshold; } } } return { feature: bestFeature, threshold: bestThreshold, gain: bestGain }; } function buildTree(data, labels, depth = 0) { if (depth >= maxDepth) return { prediction: Math.round(labels.reduce((a, b) => a + b, 0) / labels.length) }; const features = Array(features).fill(0).map((_, i) => i); const { feature, threshold, gain } = findBestSplit(data, labels, features); if (gain === 0) return { prediction: Math.round(labels.reduce((a, b) => a + b, 0) / labels.length) }; const leftIndices = [], rightIndices = []; for (let i = 0; i < data.length; i++) { if (data[i][feature] < threshold) leftIndices.push(i); else rightIndices.push(i); } const leftData = leftIndices.map(i => data[i]); const leftLabels = leftIndices.map(i => labels[i]); const rightData = rightIndices.map(i => data[i]); const rightLabels = rightIndices.map(i => labels[i]); return { feature, threshold, left: buildTree(leftData, leftLabels, depth + 1), right: buildTree(rightData, rightLabels, depth + 1) }; } const tree = buildTree(data, labels); return tree.feature !== undefined ? 1 : 0; } decisionTree();"

# Task 33
create_curl_request "function decisionTree() { const samples = 5000, features = 20, maxDepth = 10; const data = Array(samples).fill(0).map(() => Array(features).fill(0).map(() => Math.random())); const labels = Array(samples).fill(0).map(() => Math.floor(Math.random() * 2)); function calculateGini(labels) { const counts = {}; for (const label of labels) counts[label] = (counts[label] || 0) + 1; let impurity = 1; for (const label in counts) { const prob = counts[label] / labels.length; impurity -= prob * prob; } return impurity; } function findBestSplit(data, labels, features) { let bestGain = 0, bestFeature = -1, bestThreshold = 0; const baseGini = calculateGini(labels); for (const feature of features) { const values = data.map(row => row[feature]); const thresholds = [...new Set(values)].sort(); for (const threshold of thresholds) { const leftIndices = [], rightIndices = []; for (let i = 0; i < data.length; i++) { if (data[i][feature] < threshold) leftIndices.push(i); else rightIndices.push(i); } if (leftIndices.length === 0 || rightIndices.length === 0) continue; const leftLabels = leftIndices.map(i => labels[i]); const rightLabels = rightIndices.map(i => labels[i]); const leftGini = calculateGini(leftLabels); const rightGini = calculateGini(rightLabels); const gain = baseGini - (leftLabels.length / labels.length * leftGini + rightLabels.length / labels.length * rightGini); if (gain > bestGain) { bestGain = gain; bestFeature = feature; bestThreshold = threshold; } } } return { feature: bestFeature, threshold: bestThreshold, gain: bestGain }; } function buildTree(data, labels, depth = 0) { if (depth >= maxDepth) return { prediction: Math.round(labels.reduce((a, b) => a + b, 0) / labels.length) }; const features = Array(features).fill(0).map((_, i) => i); const { feature, threshold, gain } = findBestSplit(data, labels, features); if (gain === 0) return { prediction: Math.round(labels.reduce((a, b) => a + b, 0) / labels.length) }; const leftIndices = [], rightIndices = []; for (let i = 0; i < data.length; i++) { if (data[i][feature] < threshold) leftIndices.push(i); else rightIndices.push(i); } const leftData = leftIndices.map(i => data[i]); const leftLabels = leftIndices.map(i => labels[i]); const rightData = rightIndices.map(i => data[i]); const rightLabels = rightIndices.map(i => labels[i]); return { feature, threshold, left: buildTree(leftData, leftLabels, depth + 1), right: buildTree(rightData, rightLabels, depth + 1) }; } const tree = buildTree(data, labels); return tree.feature !== undefined ? 1 : 0; } decisionTree();"

# Task 34
create_curl_request "function adaBoost() { const samples = 5000, features = 20, iterations = 50; const data = Array(samples).fill(0).map(() => Array(features).fill(0).map(() => Math.random())); const labels = Array(samples).fill(0).map(() => Math.random() > 0.5 ? 1 : -1); const weights = Array(samples).fill(1 / samples); const classifiers = []; for (let t = 0; t < iterations; t++) { let bestError = Infinity, bestFeature = -1, bestThreshold = 0, bestDirection = 1; for (let feature = 0; feature < features; feature++) { const values = data.map(row => row[feature]); const thresholds = [...new Set(values)].sort(); for (const threshold of thresholds) { for (const direction of [1, -1]) { let error = 0; for (let i = 0; i < samples; i++) { const prediction = data[i][feature] < threshold ? direction : -direction; if (prediction !== labels[i]) error += weights[i]; } if (error < bestError) { bestError = error; bestFeature = feature; bestThreshold = threshold; bestDirection = direction; } } } } const alpha = 0.5 * Math.log((1 - bestError) / bestError); classifiers.push({ feature: bestFeature, threshold: bestThreshold, direction: bestDirection, alpha }); let weightsSum = 0; for (let i = 0; i < samples; i++) { const prediction = data[i][bestFeature] < bestThreshold ? bestDirection : -bestDirection; weights[i] *= Math.exp(-alpha * labels[i] * prediction); weightsSum += weights[i]; } for (let i = 0; i < samples; i++) weights[i] /= weightsSum; } let correct = 0; for (let i = 0; i < samples; i++) { let score = 0; for (const { feature, threshold, direction, alpha } of classifiers) { score += alpha * (data[i][feature] < threshold ? direction : -direction); } if ((score > 0 ? 1 : -1) === labels[i]) correct++; } return correct / samples; } adaBoost();"

# Task 35
create_curl_request "function gradientBoosting() { const samples = 5000, features = 20, trees = 50, maxDepth = 3; const data = Array(samples).fill(0).map(() => Array(features).fill(0).map(() => Math.random())); const trueFunction = x => Math.sin(x[0]) + Math.log(x[1] + 1) + x[2] * x[2] - x[3] * x[4]; const targets = data.map(trueFunction); const learningRate = 0.1; function buildTree(data, residuals, depth = 0) { if (depth >= maxDepth) return { prediction: residuals.reduce((a, b) => a + b, 0) / residuals.length }; let bestVar = 0, bestSplit = 0, bestReduction = -Infinity; const totalVar = residuals.reduce((a, b) => a + b * b, 0) / residuals.length - Math.pow(residuals.reduce((a, b) => a + b, 0) / residuals.length, 2); for (let f = 0; f < features; f++) { const values = [...new Set(data.map(d => d[f]))].sort(); for (let i = 0; i < values.length - 1; i++) { const split = (values[i] + values[i + 1]) / 2; const leftIndices = [], rightIndices = []; for (let j = 0; j < data.length; j++) { if (data[j][f] <= split) leftIndices.push(j); else rightIndices.push(j); } if (leftIndices.length === 0 || rightIndices.length === 0) continue; const leftResiduals = leftIndices.map(j => residuals[j]); const rightResiduals = rightIndices.map(j => residuals[j]); const leftMean = leftResiduals.reduce((a, b) => a + b, 0) / leftResiduals.length; const rightMean = rightResiduals.reduce((a, b) => a + b, 0) / rightResiduals.length; const leftVar = leftResiduals.reduce((a, b) => a + (b - leftMean) * (b - leftMean), 0) / leftResiduals.length; const rightVar = rightResiduals.reduce((a, b) => a + (b - rightMean) * (b - rightMean), 0) / rightResiduals.length; const weightedVar = (leftResiduals.length * leftVar + rightResiduals.length * rightVar) / residuals.length; const reduction = totalVar - weightedVar; if (reduction > bestReduction) { bestVar = f; bestSplit = split; bestReduction = reduction; } } } if (bestReduction <= 0) return { prediction: residuals.reduce((a, b) => a + b, 0) / residuals.length }; const leftIndices = [], rightIndices = []; for (let i = 0; i < data.length; i++) { if (data[i][bestVar] <= bestSplit) leftIndices.push(i); else rightIndices.push(i); } const leftData = leftIndices.map(i => data[i]); const leftResiduals = leftIndices.map(i => residuals[i]); const rightData = rightIndices.map(i => data[i]); const rightResiduals = rightIndices.map(i => residuals[i]); return { var: bestVar, split: bestSplit, left: buildTree(leftData, leftResiduals, depth + 1), right: buildTree(rightData, rightResiduals, depth + 1) }; } function predict(tree, instance) { if (tree.prediction !== undefined) return tree.prediction; return instance[tree.var] <= tree.split ? predict(tree.left, instance) : predict(tree.right, instance); } let predictions = Array(samples).fill(0); for (let t = 0; t < trees; t++) { const residuals = targets.map((y, i) => y - predictions[i]); const tree = buildTree(data, residuals); for (let i = 0; i < samples; i++) { predictions[i] += learningRate * predict(tree, data[i]); } } let mse = 0; for (let i = 0; i < samples; i++) { mse += (targets[i] - predictions[i]) * (targets[i] - predictions[i]); } return Math.sqrt(mse / samples); } gradientBoosting();"

# Task 36
create_curl_request "function dbscan() { const points = 5000, dimensions = 3, eps = 0.1, minPts = 10; const data = Array(points).fill(0).map(() => Array(dimensions).fill(0).map(() => Math.random())); function distance(a, b) { let sum = 0; for (let i = 0; i < dimensions; i++) { sum += (a[i] - b[i]) * (a[i] - b[i]); } return Math.sqrt(sum); } function getNeighbors(point, index) { const neighbors = []; for (let i = 0; i < points; i++) { if (i !== index && distance(point, data[i]) <= eps) { neighbors.push(i); } } return neighbors; } const visited = Array(points).fill(false); const clusters = Array(points).fill(-1); let clusterCount = 0; for (let i = 0; i < points; i++) { if (visited[i]) continue; visited[i] = true; const neighbors = getNeighbors(data[i], i); if (neighbors.length < minPts) { clusters[i] = -1; } else { clusters[i] = clusterCount; for (let j = 0; j < neighbors.length; j++) { const neighbor = neighbors[j]; if (!visited[neighbor]) { visited[neighbor] = true; const neighborNeighbors = getNeighbors(data[neighbor], neighbor); if (neighborNeighbors.length >= minPts) { neighbors.push(...neighborNeighbors.filter(n => !visited[n] && !neighbors.includes(n))); } } if (clusters[neighbor] === -1) { clusters[neighbor] = clusterCount; } } clusterCount++; } } const counts = {}; for (const cluster of clusters) { counts[cluster] = (counts[cluster] || 0) + 1; } return clusterCount; } dbscan();"

# Task 37
create_curl_request "function gmm() { const samples = 5000, dimensions = 5, clusters = 5, iterations = 20; const data = Array(samples).fill(0).map(() => Array(dimensions).fill(0).map(() => Math.random() * 10)); function mvnpdf(x, mean, cov) { const n = mean.length; const xMinusMu = Array(n).fill(0); for (let i = 0; i < n; i++) xMinusMu[i] = x[i] - mean[i]; let exponent = 0; for (let i = 0; i < n; i++) { for (let j = 0; j < n; j++) { exponent += xMinusMu[i] * (i === j ? 1 / cov[i] : 0) * xMinusMu[j]; } } return Math.exp(-0.5 * exponent) / Math.sqrt(Math.pow(2 * Math.PI, n) * cov.reduce((a, b) => a * b, 1)); } const means = Array(clusters).fill(0).map(() => Array(dimensions).fill(0).map(() => Math.random() * 10)); const covariances = Array(clusters).fill(0).map(() => Array(dimensions).fill(1)); const weights = Array(clusters).fill(1 / clusters); for (let iter = 0; iter < iterations; iter++) { const responsibilities = Array(samples).fill(0).map(() => Array(clusters).fill(0)); for (let i = 0; i < samples; i++) { let sum = 0; for (let k = 0; k < clusters; k++) { responsibilities[i][k] = weights[k] * mvnpdf(data[i], means[k], covariances[k]); sum += responsibilities[i][k]; } for (let k = 0; k < clusters; k++) { responsibilities[i][k] /= sum; } } for (let k = 0; k < clusters; k++) { const nk = responsibilities.reduce((sum, r) => sum + r[k], 0); for (let j = 0; j < dimensions; j++) { means[k][j] = 0; for (let i = 0; i < samples; i++) { means[k][j] += responsibilities[i][k] * data[i][j]; } means[k][j] /= nk; } for (let j = 0; j < dimensions; j++) { covariances[k][j] = 0; for (let i = 0; i < samples; i++) { covariances[k][j] += responsibilities[i][k] * Math.pow(data[i][j] - means[k][j], 2); } covariances[k][j] /= nk; covariances[k][j] = Math.max(covariances[k][j], 1e-6); } weights[k] = nk / samples; } } let logLikelihood = 0; for (let i = 0; i < samples; i++) { let sum = 0; for (let k = 0; k < clusters; k++) { sum += weights[k] * mvnpdf(data[i], means[k], covariances[k]); } logLikelihood += Math.log(sum); } return logLikelihood / samples; } gmm();"

# Task 38
create_curl_request "function pca() { const samples = 5000, dimensions = 50, components = 10; const data = Array(samples).fill(0).map(() => Array(dimensions).fill(0).map(() => Math.random())); const mean = Array(dimensions).fill(0); for (let i = 0; i < samples; i++) { for (let j = 0; j < dimensions; j++) { mean[j] += data[i][j]; } } for (let j = 0; j < dimensions; j++) { mean[j] /= samples; } for (let i = 0; i < samples; i++) { for (let j = 0; j < dimensions; j++) { data[i][j] -= mean[j]; } } const covariance = Array(dimensions).fill(0).map(() => Array(dimensions).fill(0)); for (let i = 0; i < samples; i++) { for (let j = 0; j < dimensions; j++) { for (let k = 0; k < dimensions; k++) { covariance[j][k] += data[i][j] * data[i][k]; } } } for (let j = 0; j < dimensions; j++) { for (let k = 0; k < dimensions; k++) { covariance[j][k] /= (samples - 1); } } const vectors = Array(components).fill(0).map(() => Array(dimensions).fill(0).map(() => Math.random())); for (let iter = 0; iter < 10; iter++) { for (let c = 0; c < components; c++) { const newVector = Array(dimensions).fill(0); for (let i = 0; i < dimensions; i++) { for (let j = 0; j < dimensions; j++) { newVector[i] += covariance[i][j] * vectors[c][j]; } } const norm = Math.sqrt(newVector.reduce((sum, val) => sum + val * val, 0)); for (let i = 0; i < dimensions; i++) { vectors[c][i] = newVector[i] / norm; } for (let p = 0; p < c; p++) { const dot = vectors[c].reduce((sum, val, idx) => sum + val * vectors[p][idx], 0); for (let i = 0; i < dimensions; i++) { vectors[c][i] -= dot * vectors[p][i]; } } const norm2 = Math.sqrt(vectors[c].reduce((sum, val) => sum + val * val, 0)); for (let i = 0; i < dimensions; i++) { vectors[c][i] /= norm2; } } } const projection = Array(samples).fill(0).map(() => Array(components).fill(0)); for (let i = 0; i < samples; i++) { for (let c = 0; c < components; c++) { for (let j = 0; j < dimensions; j++) { projection[i][c] += data[i][j] * vectors[c][j]; } } } const reconstruction = Array(samples).fill(0).map(() => Array(dimensions).fill(0)); for (let i = 0; i < samples; i++) { for (let j = 0; j < dimensions; j++) { for (let c = 0; c < components; c++) { reconstruction[i][j] += projection[i][c] * vectors[c][j]; } } } let error = 0; for (let i = 0; i < samples; i++) { for (let j = 0; j < dimensions; j++) { error += (data[i][j] - reconstruction[i][j]) * (data[i][j] - reconstruction[i][j]); } } return Math.sqrt(error / (samples * dimensions)); } pca();"

# Task 39
create_curl_request "function hierarchicalClustering() { const points = 500, dimensions = 5; const data = Array(points).fill(0).map(() => Array(dimensions).fill(0).map(() => Math.random())); function distance(a, b) { let sum = 0; for (let i = 0; i < dimensions; i++) { sum += (a[i] - b[i]) * (a[i] - b[i]); } return Math.sqrt(sum); } const clusters = data.map((point, index) => ({ points: [index], center: point })); while (clusters.length > 1) { let minDist = Infinity, minI = -1, minJ = -1; for (let i = 0; i < clusters.length; i++) { for (let j = i + 1; j < clusters.length; j++) { const dist = distance(clusters[i].center, clusters[j].center); if (dist < minDist) { minDist = dist; minI = i; minJ = j; } } } const newCenter = Array(dimensions).fill(0); const totalPoints = clusters[minI].points.length + clusters[minJ].points.length; for (let i = 0; i < dimensions; i++) { newCenter[i] = (clusters[minI].center[i] * clusters[minI].points.length + clusters[minJ].center[i] * clusters[minJ].points.length) / totalPoints; } clusters.push({ points: [...clusters[minI].points, ...clusters[minJ].points], center: newCenter }); clusters.splice(minJ, 1); clusters.splice(minI, 1); if (clusters.length <= 10) break; } return clusters.reduce((sum, cluster) => sum + cluster.points.length, 0); } hierarchicalClustering();"

# Task 40
create_curl_request "function t_sne() { const samples = 500, inputDim = 50, outputDim = 2, perplexity = 30, iterations = 100; const data = Array(samples).fill(0).map(() => Array(inputDim).fill(0).map(() => Math.random())); const Y = Array(samples).fill(0).map(() => Array(outputDim).fill(0).map(() => Math.random() * 0.0001)); function euclideanDist(a, b) { let sum = 0; for (let i = 0; i < a.length; i++) { sum += (a[i] - b[i]) * (a[i] - b[i]); } return Math.sqrt(sum); } const D = Array(samples).fill(0).map(() => Array(samples).fill(0)); for (let i = 0; i < samples; i++) { for (let j = 0; j < samples; j++) { D[i][j] = euclideanDist(data[i], data[j]); } } const P = Array(samples).fill(0).map(() => Array(samples).fill(0)); for (let i = 0; i < samples; i++) { const beta = 1.0; const distances = D[i].map(d => Math.exp(-d * d * beta)).map((v, j) => i === j ? 0 : v); const sum = distances.reduce((a, b) => a + b, 0); for (let j = 0; j < samples; j++) { P[i][j] = i === j ? 0 : distances[j] / sum; } } for (let i = 0; i < samples; i++) { for (let j = 0; j < samples; j++) { P[i][j] = (P[i][j] + P[j][i]) / (2 * samples); } } const learningRate = 10; for (let iter = 0; iter < iterations; iter++) { const Q = Array(samples).fill(0).map(() => Array(samples).fill(0)); const distances = Array(samples).fill(0).map(() => Array(samples).fill(0)); for (let i = 0; i < samples; i++) { for (let j = i + 1; j < samples; j++) { let dist = 0; for (let k = 0; k < outputDim; k++) { dist += (Y[i][k] - Y[j][k]) * (Y[i][k] - Y[j][k]); } distances[i][j] = distances[j][i] = 1 / (1 + dist); } } const sumQ = distances.reduce((sum, row) => sum + row.reduce((a, b) => a + b, 0), 0); for (let i = 0; i < samples; i++) { for (let j = 0; j < samples; j++) { Q[i][j] = i === j ? 0 : distances[i][j] / sumQ; } } const dY = Array(samples).fill(0).map(() => Array(outputDim).fill(0)); for (let i = 0; i < samples; i++) { for (let j = 0; j < samples; j++) { if (i === j) continue; const factor = 4 * (P[i][j] - Q[i][j]) * distances[i][j]; for (let k = 0; k < outputDim; k++) { dY[i][k] += factor * (Y[i][k] - Y[j][k]); } } } for (let i = 0; i < samples; i++) { for (let k = 0; k < outputDim; k++) { Y[i][k] += learningRate * dY[i][k]; } } } let sum = 0; for (let i = 0; i < samples; i++) { for (let k = 0; k < outputDim; k++) { sum += Y[i][k] * Y[i][k]; } } return Math.sqrt(sum / (samples * outputDim)); } t_sne();"

# Task 41
create_curl_request "function linearRegression() { const samples = 10000, features = 20; const X = Array(samples).fill(0).map(() => Array(features).fill(0).map(() => Math.random())); const trueWeights = Array(features).fill(0).map(() => Math.random() * 2 - 1); const y = X.map(x => x.reduce((sum, val, idx) => sum + val * trueWeights[idx], 0) + Math.random() * 0.1); const weights = Array(features).fill(0); const learningRate = 0.01; const iterations = 100; for (let iter = 0; iter < iterations; iter++) { const predictions = X.map(x => x.reduce((sum, val, idx) => sum + val * weights[idx], 0)); const errors = predictions.map((pred, idx) => pred - y[idx]); const gradients = Array(features).fill(0); for (let j = 0; j < features; j++) { for (let i = 0; i < samples; i++) { gradients[j] += errors[i] * X[i][j]; } gradients[j] /= samples; } for (let j = 0; j < features; j++) { weights[j] -= learningRate * gradients[j]; } } const predictions = X.map(x => x.reduce((sum, val, idx) => sum + val * weights[idx], 0)); let mse = 0; for (let i = 0; i < samples; i++) { mse += (predictions[i] - y[i]) * (predictions[i] - y[i]); } return Math.sqrt(mse / samples); } linearRegression();"

# Task 42
create_curl_request "function lasso() { const samples = 5000, features = 50; const X = Array(samples).fill(0).map(() => Array(features).fill(0).map(() => Math.random())); const trueWeights = Array(features).fill(0).map((_, i) => i < 10 ? Math.random() * 2 - 1 : 0); const y = X.map(x => x.reduce((sum, val, idx) => sum + val * trueWeights[idx], 0) + Math.random() * 0.1); const weights = Array(features).fill(0); const learningRate = 0.01, lambda = 0.1, iterations = 100; for (let iter = 0; iter < iterations; iter++) { const predictions = X.map(x => x.reduce((sum, val, idx) => sum + val * weights[idx], 0)); const errors = predictions.map((pred, idx) => pred - y[idx]); const gradients = Array(features).fill(0); for (let j = 0; j < features; j++) { for (let i = 0; i < samples; i++) { gradients[j] += errors[i] * X[i][j] / samples; } gradients[j] += lambda * Math.sign(weights[j]); } for (let j = 0; j < features; j++) { weights[j] -= learningRate * gradients[j]; } } const predictions = X.map(x => x.reduce((sum, val, idx) => sum + val * weights[idx], 0)); let mse = 0; for (let i = 0; i < samples; i++) { mse += (predictions[i] - y[i]) * (predictions[i] - y[i]); } return Math.sqrt(mse / samples); } lasso();"

# Task 43
create_curl_request "function ridge() { const samples = 5000, features = 50; const X = Array(samples).fill(0).map(() => Array(features).fill(0).map(() => Math.random())); const trueWeights = Array(features).fill(0).map(() => Math.random() * 2 - 1); const y = X.map(x => x.reduce((sum, val, idx) => sum + val * trueWeights[idx], 0) + Math.random() * 0.1); const weights = Array(features).fill(0); const learningRate = 0.01, lambda = 0.1, iterations = 100; for (let iter = 0; iter < iterations; iter++) { const predictions = X.map(x => x.reduce((sum, val, idx) => sum + val * weights[idx], 0)); const errors = predictions.map((pred, idx) => pred - y[idx]); const gradients = Array(features).fill(0); for (let j = 0; j < features; j++) { for (let i = 0; i < samples; i++) { gradients[j] += errors[i] * X[i][j] / samples; } gradients[j] += lambda * weights[j]; } for (let j = 0; j < features; j++) { weights[j] -= learningRate * gradients[j]; } } const predictions = X.map(x => x.reduce((sum, val, idx) => sum + val * weights[idx], 0)); let mse = 0; for (let i = 0; i < samples; i++) { mse += (predictions[i] - y[i]) * (predictions[i] - y[i]); } return Math.sqrt(mse / samples); } ridge();"

# Task 44
create_curl_request "function logisticRegression() { const samples = 5000, features = 20; const X = Array(samples).fill(0).map(() => Array(features).fill(0).map(() => Math.random())); const trueWeights = Array(features).fill(0).map(() => Math.random() * 2 - 1); const probabilities = X.map(x => 1 / (1 + Math.exp(-x.reduce((sum, val, idx) => sum + val * trueWeights[idx], 0)))); const y = probabilities.map(p => Math.random() < p ? 1 : 0); const weights = Array(features).fill(0); const learningRate = 0.1, iterations = 100; function sigmoid(z) { return 1 / (1 + Math.exp(-z)); } for (let iter = 0; iter < iterations; iter++) { const predictions = X.map(x => sigmoid(x.reduce((sum, val, idx) => sum + val * weights[idx], 0))); const errors = predictions.map((pred, idx) => pred - y[idx]); const gradients = Array(features).fill(0); for (let j = 0; j < features; j++) { for (let i = 0; i < samples; i++) { gradients[j] += errors[i] * X[i][j]; } gradients[j] /= samples; } for (let j = 0; j < features; j++) { weights[j] -= learningRate * gradients[j]; } } const predictions = X.map(x => sigmoid(x.reduce((sum, val, idx) => sum + val * weights[idx], 0)) > 0.5 ? 1 : 0); let accuracy = 0; for (let i = 0; i < samples; i++) { if (predictions[i] === y[i]) accuracy++; } return accuracy / samples; } logisticRegression();"
